$Q=1
/* 42: COMMAND PROCESSOR */

2900H: DECLARE DOS42 LITERALLY '3206H';

DECLARE
    LF  LITERALLY '10',
    CR  LITERALLY '13';

MON1: PROCEDURE(F,A);
    DECLARE F BYTE,
    A ADDRESS;
    GO TO DOS42;
    END MON1;

MON2: PROCEDURE(F,A) BYTE;
    DECLARE F BYTE,
    A ADDRESS;
    GO TO DOS42;
    END MON2;

READCHAR: PROCEDURE BYTE;
    RETURN MON2(1,0);
    END READCHAR;

PRINTCHAR: PROCEDURE(CHAR);
    DECLARE CHAR BYTE;
    CALL MON1(2,CHAR);
    END PRINTCHAR;

CRLF: PROCEDURE;
    CALL PRINTCHAR(CR);
    CALL PRINTCHAR(LF);
    END CRLF;

PRINT: PROCEDURE(A);
    DECLARE A ADDRESS;
    /* PRINT THE STRING STARTING AT ADDRESS A UNTIL THE
    NEXT DOLLAR SIGN IS ENCOUNTERED */
    CALL CRLF;
    CALL MON1(9,A);
    END PRINT;

MOVE: PROCEDURE(A,B,L);
    /* MOVE FROM A TO B FOR L BYTES (L <= 255) */
    DECLARE (A, B) ADDRESS,
    (S BASED A, D BASED B, L) BYTE;
        DO WHILE (L := L - 1) <> 255;
        D = S; B = B + 1; A = A + 1;
        END;
    END MOVE;

READ: PROCEDURE(A);
    DECLARE A ADDRESS;
    /* READ INTO BUFFER AT A+2 */
    CALL MON1(10,A);
    END READ;

DECLARE (MAXLEN,COMLEN) BYTE, /* MAXIMUM AND CURRENT LENGTH */
    COMBUFF(128) BYTE,                /* COMMAND BUFFER */
    (TCBP,CBP) BYTE;                  /* BUFFER POINTERS */

READCOM: PROCEDURE;
    /* READ INTO COMMAND BUFFER */
    MAXLEN = 128;
    CALL READ(.MAXLEN);
    END READCOM;

GETCOM: PROCEDURE(I) BYTE;
    DECLARE I BYTE;
    RETURN COMBUFF(I);
    END GETCOM;

DO;
CALL PRINT(.'CCP4.2$');
CALL CRLF;
CALL PRINT(.'NO DISK SUPPORT$');
CALL PRINT(.'ONLY BASIC DDT COMMANDS$');
CALL CRLF;
CALL READCOM;
CALL CRLF;
CALL PRINTCHAR(GETCOM(0));
CALL PRINTCHAR(GETCOM(1));

END; /* OF CONTROL PROGRAM */

EOF;
